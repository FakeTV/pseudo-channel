from src import PseudoChannelDatabase
from src import Movie
from src import Commercial
from src import Episode
from src import Music
from src import Video
from pseudo_config import *

from plexapi.server import PlexServer

import datetime
from xml.dom import minidom
import xml.etree.ElementTree as ET

class PseudoChannel():

	PLEX = PlexServer(baseurl, token)

	MEDIA = []

	def __init__(self):

		self.db = PseudoChannelDatabase("pseudo-channel.db")

	"""Database functions.

		update_db(): Grab the media from the Plex DB and store it in the local pseudo-channel.db.

		drop_db(): Drop the local database. Fresh start. 

		update_schedule(): Update schedule with user defined times.

		drop_schedule(): Drop the user defined schedule table. 

		generate_daily_schedule(): Generates daily schedule based on the "schedule" table.
	"""

	def update_db(self):

		print("Updating Local Database")

		self.db.create_tables()

		sections = self.PLEX.library.sections()

		for section in sections:

			if section.title == "Movies":

				sectionMedia = self.PLEX.library.section(section.title).all()

				for media in sectionMedia:

					self.db.add_movies_to_db(1, media.title, media.duration)

			elif section.title == "TV Shows":

				sectionMedia = self.PLEX.library.section(section.title).all()

				for media in sectionMedia:

					backgroundImagePath = self.PLEX.library.section(section.title).get(media.title)

					backgroundImgURL = ''

					if isinstance(backgroundImagePath.art, str):

						backgroundImgURL = baseurl+backgroundImagePath.art+"?X-Plex-Token="+token

					self.db.add_shows_to_db(2, media.title, media.duration, '', backgroundImgURL)

					#add all episodes of each tv show to episodes table
					episodes = self.PLEX.library.section(section.title).get(media.title).episodes()

					for episode in episodes:

						duration = episode.duration

						if duration:

							self.db.add_episodes_to_db(4, episode.title, duration, episode.index, episode.parentIndex, media.title)

						else:

							self.db.add_episodes_to_db(4, episode.title, 0, episode.index, episode.parentIndex, media.title)

			elif section.title == "Commercials":

				sectionMedia = self.PLEX.library.section(section.title).all()

				for media in sectionMedia:

					self.db.add_commercials_to_db(3, media.title, media.duration)

	def update_schedule(self):

		scheduled_days_list = [
			"mondays",
			"tuesdays",
			"wednesdays",
			"thursdays",
			"fridays",
			"saturdays",
			"sundays",
			"weekdays",
			"weekends",
			"everyday"
		]

		section_dict = {
			"TV Shows" : ["series", "shows", "tv", "episodes", "tv shows"],
			"Movies"   : ["movie", "movies", "films", "film"],
			"Videos"   : ["video", "videos", "vid"],
			"Music"    : ["music", "songs", "song", "tune", "tunes"]
		}

		tree = ET.parse('pseudo_schedule.xml')

		root = tree.getroot()

		for child in root:

			if child.tag in scheduled_days_list:

				print child.find( "time" )

				for time in child.iter("time"):

					for key, value in section_dict.items():

						if time.attrib['type'] == key or time.attrib['type'] in value:

							print time.tag, time.text, time.attrib['title']

							title = time.attrib['title']

							natural_start_time = time.text

							section = key

							strict_time = time.attrib['strict-time']

	def drop_db(self):

		self.db.drop_db()

	def drop_schedule(self):

		self.db.drop_schedule()

	def remove_all_scheduled_items():

		self.db.remove_all_scheduled_items()



	"""App functions.

		generate_daily_schedule(): Generate the daily_schedule table.
	"""

	'''
	*
	* Using datetime to figure out when the media item will end based on the scheduled start time or the offset 
	* generated by the previous media item. 

	* Returns time 
	*
	'''
	def get_end_time_from_duration(self, startTime, duration):

		time = datetime.datetime.strptime(startTime, '%I:%M %p')

		show_time_plus_duration = time + datetime.timedelta(milliseconds=duration)

		#print(show_time_plus_duration.minute)

		return show_time_plus_duration

	def generate_daily_schedule(self):

		print("Generating Daily Schedule")

		schedule = self.db.get_schedule()

		for entry in schedule:

			section = entry[9]

			if section == "TV Shows":

				next_episode = self.db.get_next_episode(entry[3])

				if next_episode != None:
				
					episode = Episode(
						section, # section_type
						next_episode[3], # title
						entry[5], # natural_start_time
						self.get_end_time_from_duration(entry[5], next_episode[4]), # natural_end_time
						next_episode[4], # duration
						entry[7], # day_of_week
						False, # is_strict_time
						entry[3], # show_series_title
						next_episode[5], # episode_number
						next_episode[6] # season_number
						)

				else:

					print("Cannot find TV Show Episode, {} in the local db".format(entry[3]))

				#print(episode)

				self.MEDIA.append(episode)

			elif section == "Movies":

				the_movie = self.db.get_movie(entry[3])

				if the_movie != None:

					movie = Movie(
					section, # section_type
					the_movie[3], # title
					entry[5], # natural_start_time
					self.get_end_time_from_duration(entry[5], the_movie[4]), # natural_end_time
					the_movie[4], # duration
					entry[7], # day_of_week
					False, # is_strict_time
					)

					#print(movie.natural_end_time)

					self.MEDIA.append(movie)

				else:

					print("Cannot find Movie, {} in the local db".format(entry[3]))

			elif section == "Music":

				the_music = self.db.get_music(entry[3])

				if the_music != None:

					music = Music(
					section, # section_type
					the_music[3], # title
					entry[5], # natural_start_time
					self.get_end_time_from_duration(entry[5], the_music[4]), # natural_end_time
					the_music[4], # duration
					entry[7], # day_of_week
					False, # is_strict_time
					)

					#print(music.natural_end_time)

					self.MEDIA.append(music)

				else:

					print("Cannot find Music, {} in the local db".format(entry[3]))

			elif section == "Video":

				the_video = self.db.get_video(entry[3])

				if the_music != None:

					video = Video(
					section, # section_type
					the_video[3], # title
					entry[5], # natural_start_time
					self.get_end_time_from_duration(entry[5], the_video[4]), # natural_end_time
					the_video[4], # duration
					entry[7], # day_of_week
					False, # is_strict_time
					)

					#print(music.natural_end_time)

					self.MEDIA.append(video)

				else:

					print("Cannot find Video, {} in the local db".format(entry[3]))

			else:

				pass

if __name__ == '__main__':

	pseudo_channel = PseudoChannel()

	pseudo_channel.update_schedule()

	#pseudo_channel.generate_daily_schedule()

	"""for item in pseudo_channel.MEDIA:

		if item.day_of_week == "saturdays":

			print(item.title)"""
			#pass
		
	#pseudo_channel.update_db()

